#　typescriptとは

javascirptのスーパーセット*
静的型付き言語で、プログラムの正しさを静的に検査できる
大きなエコシステム*を持っている
マイクロソフトが開発

## javascirptのスーパーセット
スーパーセットとは元の言語と仲良くしつつ、さらにそこから発展させたもの。
なのでjavascriptのコードは全てtypescirptとして扱える
型注釈、インターフェース、ジェネリクスなどの独自機能がある

## 静的な検査
静的に検査できるとは、実行せずにバグのチェックがおこなること
javascriptではできなかった。
なのでコーディング時に問題を見つけてくれるのでバグを防げる。
重要システムの開発では安心材料になる

## 検査の仕組み
型システムに基づいて行われる。
それに基づき、コンパイル*のタイミングで検査をする。

### 型システム
boolernとかそういうの。
決められた値、決められた操作のみが行える
これは数学の型理論を背景に作られた。数学的証明によりプログラムの欠陥を炙り出せる。

###　型注釈*
（変数名）: (型名)みたいのを型注釈という。

###　型推論
文脈でなんとーなく型の予想がつく場合、型が自動で判断される。これのおかげで楽できる
今まで指定してなかったものもこれが影響していたんだね

### コンパイル
typescriptを実行するためにjavascriptへ変換することを言う。
変換後のjavascriptコードはブラウザやサーバーで時効できる。なのために？
検査もこのタイミングだね。まあそりゃそうか、変換しちゃったら面倒だし

型情報はドキュメントにもなるし、リファクタリングを安全にし、そのほかツールサポートが充実してる

## いろんなものが作れる
webアプリ、サーバーサイド、モバイル、デスクトップ、クラウド関連機能、CLIツール、インフラ構成管理、拡張機能など色々作れる



##　基本的な型

### プリミティブ型
boolean: 真偽値。
number: 数値。
string: 文字列。
bigint: 大きな整数。
symbol: 一意の値を示す。
undefined: 値が定義されていない状態を示す。
null: 値が存在しない状態を示す
よくあるやつだね

### 特殊な型
any:なんでも入れられる
unknown:なんでもいられるけど制限はするみたいな
void:値が存在しないことを示す。*関数が何も返さない場合に使用する。
never: 絶対何も返さないマン。エラー吐いたり無限ループのやつに充てる

### 型エイリアス
既存の型を新た斜めで定義する機能
難しい型を簡素に表したり、コード可読性向上に役立つ
二つの方を持てるよーって感じ

### 構造的部分型
変数の代入可否を、構造が互換しているかに着目する
型AとBとがあり、新たに変数を代入する場合それぞれの型に合致していればOK、わかりづらいな

## 配列

###　配列リテラル
配列の値を作るのに必要（[]）
const numbers = [1,2,3];

###　配列の型注釈
型名[]かarray<型名>を使う
let nubers: number[];
let strings: Array<string>;

###　配列要素へのアクセス
配列要素にアクセスするにはインデックス*を使う
0を起点に指定しろバカ

### 読み取り専用配列
値の変更できない配列。型注釈にreadonlyをつけるとそうなる


## 配列のループ
お馴染みfor...of構文あるよ
const numbers = [1, 2, 3];
 
for (const num of numbers) {
  console.log(num); // 1, 2, 3と出力される
}

### タプル型
配列の要素数と要素の型が固定される
let tuple: [string, number];
tuple = ["hello", 10]; // 代入できる
tuple = [10, "hello"]; // 順序が正しくないため、代入できない
Type 'number' is not assignable to type 'string'.
Type 'string' is not assignable to type 'number'.
tuple = ["hello", 10, "world"]; // 要素が多すぎるため代入できない
Type '[string, number, string]' is not assignable to type '[string, number]'.
  Source has 3 element(s) but target allows only 2.

### タプル要素へのアクセス
配列同様インデックスを使う

いまいちこいつらの用途わかんねーな


## オブジェクト
オブジェクトリテラル（{}）を使う
{ プロパティキー：　値、...}みたいな感じ

### プロパティアクセス
.を使ってアクセスできる

### オブジェクトの型注釈
{プロパティ１： 型１,プロパティ２:型２,...}ってゆう感じ
`let obj: { name: string; age: number };`
紛らわしいな

### readonlyプロパティ
コレつけたやつは代入できない

### オプションプロパティ
オプションプロパティ（？）をつけたプロパティは省略可能
```
let obj: { name: string; age?: number };
obj = { name: "John" }; // `age`プロパティがなくてもエラーにならない
```

### オブジェクトメソッド
関数をプロパティにもつオブジェクト
```
const obj = {
  a: 1,
  b: 2,
  sum(): number {
    return this.a + this.b;
  },
};
console.log(obj.sum());
```

### インデックス型
オブジェクトはインデックス型を利用して任意のキーの値を取得できる
[キー名: プロパティキーの型]: プロパティ値の型
で型注釈する
let obj: { [key: string]: number };
obj = { key1: 1, key2: 2 };
console.log(obj["key1"]);
console.log(obj["key2"]);

### 速記法のプロパティ名
プロパティの値が定義されているなら、プロパティ名を省略できる
const name = "John";
const age = 20;
const obj = { name, age };
*本当はconst obj = { name:john, age:20 }ってやる
console.log(obj);
{ name: 'John', age: 20 }

### オプショナルチェーン
プロパティが存在するか不確定である場合に?.演算子で安全にアクセスできる


## Map

### Mapオブジェクト　
キーとそれに対応する値を対にしたコレクション
const map = new Map();
map.set("name", "John");
map.set("age", "20");
なんでMapに型注射うが必要？*
 
console.log(map.get("name"));

### Mapの型注釈
Map<キーの型、値の型>の形で記述する
`let people: Map<string, number>;`

### mapのループ
for...ofでループすると各エントリーがキーと値の配列として順に取得できる
順序は追加した順が保証される

## Set
同じ値を追加できなくするコレクション*
set要素はなんでも可能?*
const set = new Set();
set.add(1);
set.add(2);
set.add(2); // 同じ値は追加されない。

### 型注釈
Set<要素の型>
### ループ
順序はaddした順。
for (const value of set) {
  console.log(value);
}


## 列挙型（Enum）
enumから始めてひとまとまりの文字列値を定義する。
enum Color {
  Red,
  Green,
  Blue,
}

### 値を設定する
文字・数字で定義可能
### 利用法
ドット演算子を使う

## ユニオン型
複数の方のうちいずれかをとる？と言う表現ができる
型１　|　型２| ... の形式で使う
１つん変数に複数の型を設定できるっつーこと

### 判別可能なユニオン型
わかんねえ。複雑*

##　インターセクション型　
複数の型を融合する。型１　＆　型２ &...っていう感じでやる
合成した型は合成元の型の持つプロパティとメソッドを持つ

## 分割代入
[a,b] = [1,2]
一度に変数に代入できる


## 条件分岐
ifやswitchも扱えるよ

### 型の絞り込み
意味不明。*



## 関数
アロー関数や関数宣言にも型注釈つけられる。なんでこんなことする？*


### 分割代入引数
関数の引数に配列またはオブジェクトリテラルを展開できる（キチガイすぎ）*
まあ引数内で分割代入するって感じやね

###　型ガード関数
特定の型であるか判定する

### オプション引数
？をつけることで任意とすることができる

### デフォルト引数
よくある初期値のやつ

###　残余引数
...を使って
わかんねえ*

## クラス

###　クラス構文
クラス構文をそのまま使える。クラス構文って何*
フィールド宣言に型注釈をつけられる

### アクセス修飾子*
public,protected,privateの３つが使える
readonly修飾子も使える

###　コンストラクタの省略形
コンストラクタパラメータにアクセス修飾子をつけると自動的にフィールドが定義される*

###　 フィールドの初期化子
フィールド宣言と同時に直接右初期値を設定できる

###　静的フィールドと静的メソッド
staticキーワードを使うことでインスタンスではなくクラス自体に関連するフィールドやメソッドを定義できる

### this型
メソッド内でthisを返すことでメソッドの呼び出しを直列に繋げるメソッドチェーンを可能にする*

### クラスの継承
extendキーワードでできる

### instanceof演算子
オブジェクトが特定のクラスのインスタンスであるか判定

### 抽象クラス
abstractキーワードにより抽象クラスを定義できる。
抽象クラスはインスタンス化*できず他のクラスが継承する基底クラスに使われる

### ゲッターとセッター
オブジェクトのプロパティ取得・設定をするためのメソッド
get,setキーワードで定義する

###　インターフェース
interfaceキーワードで定義する
プロパティ、メソッド、クラスなどの形状を定義する
特定のクラスまたはオブジェクトが、特定のプロパティまたはメソッドを保持することを矯正する

###　インターフェース構文
オブジェクトの形状を定義することもできる
プロパティやメソッドのシグネイチャ*を記述できる

### readonlyも使える